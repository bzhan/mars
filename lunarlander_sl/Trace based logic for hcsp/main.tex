\documentclass{llncs}
\pagestyle{plain}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{stmaryrd}
\usepackage{graphpap}
\usepackage{color}
\usepackage{listings}
\usepackage{prftree}

\newcommand{\mycomment}[1]{{\color{red}[#1]} }


\input{environment}
\input{userdef}
\newcommand{\leadm}[1]{\xrightarrow{#1}}
\newcommand{\seman}[1]{[\![#1 ]\!]}
\newcommand{\updateh}[4]{#1 \langle #2, #3, #4 \rangle}
\newcommand{\rdy}{\mathit{rdy}}
\newcommand{\pblks}{\mathit{pblks}}
\newcommand{\blks}{\mathit{blks}}
\newcommand{\combine}{\mathit{combine}}
\newcommand{\ommit}[1]{}

\begin{document}

\mainmatter

\title{A Trace Based Logic for Hybrid CSP in Isabelle}
\author{ }
\institute{ }


\maketitle

 \section{The syntax of HCSP}
 
 The syntax of a subset of HCSP is given as follows:
\[
\begin{array}{lll}
 P  & ::= & \pskip \mid x :=e  \mid ch?x \mid ch!e  \mid P;Q  \mid B \rightarrow P\mid  P \sqcup Q \mid P^*\\
      && \mid \evo{s}{e}{B} \mid \exempt{\evon{s}{e}}{i\in I}{io_i}{Q_i}\\
 S &::=& P \mid S\|S
  \end{array}
 \]
where $P, Q, Q_i, S$ are HCSP processes, $x$ and $s$ stand for process variables,
 $ch$ for channel name, $io_i$ for a communication event (either input $ch?x$ or output  $ch!e$),
$B$ and $e$ for Boolean and arithmetic expressions,
 and $I$ for a non-empty set of indices of communications, respectively.
 A whole HCSP model $S$ is defined
 as a sequential process or a parallel composition of several sequential processes at the top level.

The intuitive meaning of the individual constructs is explained as follows:
\begin{itemize}
 \item $\pskip$, $x: = e$ are defined as usual.
%terminates immediately having no effect on variables.
%\item  $x: = e$ assigns the value of expression $e$ to $x$ and then terminates.
 \item The input $ch?x$ receives a value along channel $ch$ and assigns it to $x$, and output $ch!e$ sends the value of $e$ along $ch$.
 A communication takes place as soon as both the sending party (i.e. $ch!$) and the receiving party (i.e. $ch?$) are ready, and may cause one side to wait.
 \item The sequential composition $P; Q$ behaves as $P$ first, and if it terminates, as $Q$ afterwards.
 \item The conditional $B \rightarrow P$ behaves as $P$ if $B$ is true, otherwise it terminates immediately.
 \item The internal choice $P \sqcup Q$ behaves as either $P$ or $Q$, and the non-deterministic choice is made by the system itself.
 \item The repetition $P^*$ executes $P$ for some finite number of times.
 \item $\evo{s}{e}{B}$ is the continuous
 evolution statement, where $s$ represents a vector of real variables and $\dot{s}$ the first-order derivative of $s$.
 It forces  $s$  to evolve continuously according to  the differential equation  $\dot{s}=e$ as long
 as $B$, which defines the {\em domain of $s$}, holds, and terminates when $B$ turns false. $\evo{s}{e}{B}$ is a boundary interruption.
 \item The communication interruption $\exempt{\evo{s}{e}{B}}{i\in I}{io_i}{Q_i}$ behaves like the continuous $\evo{s}{e}{B}$, except that it is preempted as soon as one of the communications $io_i$ takes place, and then is followed by the respective $Q_i$.
% Notice that, if the continuous terminates before a communication from among $\{io_i\}_{i\in I}$  occurs, then the process terminates immediately without waiting for communication.
 \item $S_1\|S_2$ behaves as if $S_1$ and $S_2$ run independently except that all communications along the common channels connecting $S_1$ and $S_2$ are to be synchronized. $S_1$ and $S_2$ in parallel can neither share variables, nor input or output channels.
\end{itemize}
 
\section{The trace-based semantics of HCSP}
 
\subsection{Trace blocks}
 
To present the trace-based semantics of HCSP, we introduce some notations below. A state $s$ maps variables to values, and it keeps changing according to the execution of processes. We define a \emph{ready set} as a pair of input and output channel names $(\mathit{InC}, \mathit{OutC})$, meaning that the input events along channels in $\mathit{InC}$ and the output events along channels in $\mathit{OutC}$ become ready, but need to wait for their respective partner event for a synchronized communication. Two ready sets $(\mathit{In}1, \mathit{Out1})$ and $(\mathit{In}2, \mathit{Out}2)$ are \emph{compatible}, iff $\mathit{In}1 \cap \mathit{Out}2 = \mathit{Out}1 \cap \mathit{In}2 = \emptyset$, i.e. there will never be the case when an input and an output along a same channel both wait for a positive time interval. 

A \emph{trace block} defines the atomic execution behavior for different HCSP processes. It includes the following types: 
\begin{itemize}
 \item $\mathtt{InBlock}(d,ch,x,v,\rdy)$ represents that the input event along channel $ch$ waits $d$ time units till the communication can occur, and at time $d$, the value $v$ sent from the partner is assigned to receiving variable $x$;  during the waiting time, the  channels in $\rdy$ keep waiting. 
 \item $\mathtt{OutBlock}(d,ch,v,\rdy)$ similarly represents an output event, except that no receiving variable is recorded.
 \item $\mathtt{TauBlock}(s)$ represents that an internal discrete action occurs, changing the state to $s$.
 \item $\mathtt{WaitBlock}(d)$ represents that a time progress of length $d$ occurs, with no variable being changed.
 \item $\mathtt{ODEBlock}(d,h)$ represents a continuous time evolution for $d$ time units, resulting in an execution history $h$, which maps each time in the interval $[0,d]$ to a state.
 \item $\mathtt{ODEInBlock}(d,h,ch,x,v,\rdy)$ represents an input communication interrupt to an ODE, where $d$ is the evolution time and $h$ the corresponding execution history for ODE; $ch$ is the input channel, $x$ receiving variable, $v$ sent from outside, and $\rdy$ the ready channels. 
 \item $\mathtt{ODEOutBlock}(d,h,ch,v,\rdy)$ represents an output communication interrupt to an ODE, similar as above case.
\end{itemize}
 
With the definition of trace blocks, a \emph{trace} is defined as a pair consisting of an initial state and a sequence of trace blocks. It specifies the behavior of a single process.

For manipulating trace blocks, we define several functions. Given a starting state $s$ and a list of blocks $\blks$, we define function $\mathtt{end}(s,blks)$ to represent the final state after the execution of $\blks$ from state $s$. This function can be defined recursively, for which the final state after executing each atomic trace block is defined clearly in their definitions. Given a list of trace blocks $\blks$ and time $t$, function $\mathtt{rdy}(blks,t)$ returns the set of ready channels at time $t$.

\subsection{Parallel trace blocks}

Above we define trace blocks for recording the trace behavior of sequential processes, next we introduce $\mathit{par\_trace}$ to record the trace for parallel processes. Currently, we only consider closed parallel processes, for which no external communication is allowed. In general, we assume there are $n$ processes in parallel, denoted by integers $1, 2, ..., n$. A parallel trace block includes three types:

\begin{itemize}
 \item $\mathtt{IOBlock}(i,j,ch,x,v)$ represents that process $i$ and $j$ perform a synchronized communication along channel $ch$ together, by assigning value $v$ to variable $x$.
       
 \item $\mathtt{ParTauBlock}(i,s)$ represents that process $i$ preforms an internal discrete action, resulting its state in $s$.
           
 \item $\mathtt{ParWaitBlock}(d,H)$ represents that all the processes in parallel perform a continuous time evolution for $d$ time units and produce a history $H$, which maps each time in $[0,d]$ to a list of states corresponding to the processes.
\end{itemize}

With the definition of parallel trace blocks, a \emph{parallel trace} is defined as a pair consisting of a list of initial states for the processes and a sequence of parallel trace blocks. In a way similar to sequential traces, we define $\mathtt{end}_p(S,\pblks)$ to return the final list of states after the execution of $\pblks$ from the initial list of states $S$. 

\paragraph{\textbf{\emph{Parallel Composition of Trace Blocks}}}
For a sequential process, we can use an initial state $s$ and a trace block list $\blks$ to represent its trace. Now we define a function $\combine$ for the parallel composition of traces, which takes a state list (i.e. the initial states for the sequential processes) and a list of trace block lists (i.e. the trace block list for the sequential processes) as input, and returns a parallel trace block list as output. At each time, the trace blocks for different processes are combined depending on their types. There are three cases:

\begin{itemize}
 \item If at the current time, there is an available $\mathtt{TauBlock}$ for some process $i$, then a $\mathtt{ParTauBlock}$ on $i$ executes. Then, the top internal block is removed from the trace block list of process $i$, and the combination of the residual trace blocks is considered recursively.

 \item When there are two processes $i$ and $j$, one with an input event being ready, and the other with an output event along the same channel being ready, then a communication block occurs on $i$ and $j$. Then the top input and output blocks are removed from the trace block lists of $i$ and $j$, and the combination of the residual trace blocks is considered recursively.

 \item When for all trace block lists, the top trace blocks have delay time greater than $t$, then a $\mathtt{ParWaitBlock}$ occurs on all the processes. In consequence, a wait block of length $t$ is removed from the trace block list of each process, then the combination of the residual trace blocks is considered recursively.
\end{itemize}
  
\subsection{Semantics}
 
For a sequential process $P$, its semantics is defined as a mapping from traces to traces. We pick some rules to illustrate the semantics. 

\begin{itemize}

\item For output event $ch!e$, its execution produces an outblock and it is attached to the tail of trace $tr$ as follows:
\[ \prftree[r]{Out}{(ch!e, tr) \Rightarrow tr ^\dagger \mathtt{OutBlock}(d,ch,v,(\{ch\}, \{\}))} \]
where $d \geq 0$ is an arbitrary delay time, $v$ is the value of $e$ under initial trace $tr$. During the delay time, only the input channel $ch$ is waiting in the ready set. 

\item For assignment $x:=e$, it produces an internal block:
\[ \prftree[r]{Assign}{(x:=e, tr) \Rightarrow tr ^\dagger \mathtt{TauBlock}(s[x \mapsto v])} \]
where $s$ is the state corresponding to $tr$ and $v$ is the value of $e$ at $s$. 

\item The sequence rule is as usual:
\[ \prftree[r]{Seq}{(P, tr_1) \Rightarrow tr_2}{(Q, tr_2) \Rightarrow tr_3}
{(P; Q, tr_1) \Rightarrow tr_3} \]

\end{itemize}

\section{Specification Logic and Inference Rules} 

\end{document}
