D ::= @M || @S1
M ::= num := 0; (num == 0 -> (E := "e"; EL := []; EL := push(EL, E); NL := []; NL := push(NL, 1); num := 1); num == 1 -> (BC1!E --> skip $ BR1?E --> EL := push(EL, E); NL := push(NL, 1); num := 1 $ BO1? --> num := num+1; NL := pop(NL); NL := push(NL, 1)); num == 2 -> (EL := pop(EL); NL := pop(NL); EL == [] -> num := 0; EL != [] -> (E := top(EL); num := top(NL))))**
S1 ::= a_S1 := 0; a_repairing := 0; a_must_repair := 0; a_waiting := 0; a_S1 := 1; re_changes := 0; ACKNACK := 1; cansend := 1; a_waiting := 1; (BC1?E; if a_repairing == 1 then done := 0; re_changes == 0 && done == 0 -> (a_repairing := 0; a_waiting := 1; done := 1); cansend == 1 && done == 0 -> (a_repairing := 0; re_changes := re_changes-1; a_repairing := 1; done := 1); done == 0 -> flag := 0 elif a_must_repair == 1 then done := 0; state_time >= 5 && done == 0 -> (a_must_repair := 0; a_repairing := 1; done := 1); ACKNACK == 1 && done == 0 -> (a_must_repair := 0; re_changes := re_changes+1; state_time := 0; a_must_repair := 1; done := 1); done == 0 -> (flag := 1; state_time := state_time+2) elif a_waiting == 1 then done := 0; re_changes > 0 && done == 0 -> (ACKNACK := 0; a_waiting := 0; state_time := 0; a_must_repair := 1; done := 1); ACKNACK == 1 && done == 0 -> (a_waiting := 0; re_changes := re_changes+1; a_waiting := 1; done := 1); done == 0 -> flag := 1 else skip endif; BO1!)**
