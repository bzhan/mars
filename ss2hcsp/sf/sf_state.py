from ss2hcsp.hcsp.hcsp import HCSP
from xml.dom.minidom import Element
from ss2hcsp.hcsp.parser import hp_parser


class SF_State:
    def __init__(self, ssid, name="", en=None, du=None, ex=None, activated=False):
        self.ssid = ssid
        self.name = name
        self.en = en  # entry
        self.du = du  # during
        self.ex = ex  # exit
        self.activated = activated
        self.father = None
        self.children = []

    def __eq__(self, other):
        return self.ssid == other.ssid

    def __str__(self):
        result = ""
        if hasattr(self, "default_tran") and self.default_tran:
            assert isinstance(self, OR_State)
            # Display the default transition
            result += str(self.default_tran)
        if isinstance(self, OR_State):
            result += "OR"
        elif isinstance(self, AND_State):
            result += "AND"
        result += "(" + self.ssid + ") " + self.name + "\n"
        if self.en:
            result += "en: [" + self.en + "]\n"
        if self.du:
            result += "du: [" + self.du + "]\n"
        if self.ex:
            result += "ex: [" + self.ex + "]\n"
        # Display output transitions
        if isinstance(self, OR_State):
            for tran in self.out_trans:
                result += str(tran) + "State or Junction(" + tran.dst + ")\n"
        # Display children
        result += "Contains states:\n"
        for child in self.children:
            result += "{" + str(child) + "}\n"
        return result

    def activate(self):
        acts = [self.en]  # acts generated by activation
        # assert not self.activated
        # self.activated = True
        # Activate children
        for child in self.children:
            if isinstance(child, (AND_State, Junction)):
                acts.extend(child.activate())
            elif isinstance(child, OR_State) and child.default_tran:
                # Activate the state with default transition
                acts.append(child.default_tran.label)  # execute the default transition
                acts.extend(child.activate())
                break
        return acts

    def exit(self):
        # assert self.activated
        # self.activated = False
        return self.ex

    def all_descendant_exit(self):
        acts = []
        for child in self.children[::-1]:  # the and_state with the lowest priority exits first
            if isinstance(child, AND_State):
                acts.extend(child.all_descendant_exit())
                acts.append(child.exit())
            elif isinstance(child, OR_State):
                # activated = "a_" + child.ssid + " == 1"
                activated = child.name
                acts.append((activated, child.all_descendant_exit()))
                acts.append(child.exit())
        return acts

    def exit_to(self, ancestor):
        assert isinstance(self, OR_State)
        assert isinstance(ancestor, (AND_State, OR_State))
        # assert ancestor.is_ancestor_of(self)
        acts = [self.exit()]
        if self.father != ancestor:
            acts.extend(self.father.exit_to(ancestor))
        return acts

    def enter_into(self, descendant):
        assert isinstance(self, (AND_State, OR_State))
        assert isinstance(descendant, (OR_State, Junction))
        # assert self.is_ancestor_of(descendant)
        # assert self.activated
        ancestor_chain = []  # from descendant to self
        cursor = descendant
        while cursor != self:
            ancestor_chain.append(cursor)
            cursor = cursor.father
        ancestor_chain.reverse()  # from self to descendant
        assert ancestor_chain == [] or ancestor_chain[0].father == self and ancestor_chain[-1] == descendant

        acts = []
        for state in ancestor_chain[:-1]:
            assert isinstance(state, OR_State)
            acts.append(state.en)
        if isinstance(descendant, OR_State):
            acts.extend(descendant.activate())
        return acts

    def get_all_descendants(self):
        assert isinstance(self, (AND_State, OR_State))
        descendants = dict()
        for child in self.children:
            assert child.ssid not in descendants
            descendants[child.ssid] = child
            if isinstance(child, (AND_State, OR_State)):
                child_descendants = child.get_all_descendants()
                for ssid in child_descendants.keys():
                    assert ssid not in descendants
                descendants.update(child_descendants)
        return descendants

    def check_children(self):
        has_AND_state = has_OR_state = has_Junction = False
        for child in self.children:
            if isinstance(child, AND_State):
                has_AND_state = True
            elif isinstance(child, OR_State):
                has_OR_state = True
            elif isinstance(child, Junction):
                has_Junction = True
            else:  # Error State
                return False
        # AND_state cannot be in the same father state with OR_state or Junction
        if has_AND_state and (has_OR_state or has_Junction):
            return False

        for child in self.children:
            if isinstance(child, (AND_State, OR_State)) and not child.check_children():
                return False
        return True

    # def is_ancestor_of(self, state):  # return if self is an ancestor of the state
    #     if state.father == self:
    #         return True
    #     if state.father is None:
    #         return False
    #     return self.is_ancestor_of(state.father)


class OR_State(SF_State):
    def __init__(self, ssid, out_trans, name="", en=None, du=None, ex=None, default_tran=None, activated=False):
        super(OR_State, self).__init__(ssid, name, en, du, ex, activated)
        self.out_trans = out_trans
        self.default_tran = default_tran  # The default transition to this state
        self.tran_acts = []  # the queue to store transition actions


class AND_State(SF_State):
    def __init__(self, ssid, name="", en=None, du=None, ex=None, order=0, activated=False):
        super(AND_State, self).__init__(ssid, name, en, du, ex, activated)
        self.order = order


class Junction:
    def __init__(self, ssid, out_trans, name="", actatived=False):
        self.ssid = ssid
        self.out_trans = out_trans
        self.name = name
        self.actatived = actatived
        self.father = None
        # self.process = None
        self.visited = False
        self.tran_acts = []  # the queue to store transition actions

    def __str__(self):
        result = "JUN(" + self.ssid + ") activated=" + str(self.actatived) + "\n"
        for tran in self.out_trans:
            result += str(tran) + "State or Junction(" + tran.dst + ")\n"
        return result

    def activate(self):
        # assert not self.actatived
        self.actatived = True

    def exit(self):
        # assert self.actatived
        self.actatived = False

    def exit_to(self, ancestor):
        assert isinstance(ancestor, (AND_State, OR_State))
        # assert ancestor.is_ancestor_of(self)
        acts = [self.exit()]
        if self.father != ancestor:
            acts.extend(self.father.exit_to(ancestor))
        return acts
